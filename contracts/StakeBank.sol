pragma solidity ^0.4.24;

import "@aragon/os/contracts/lib/math/SafeMath.sol";
import "./ownership/Ownable.sol";
import "./minime/MiniMeTokenProxyTarget.sol";
import "./proxy/Forwarder1.sol";

/**
 * @title Contract handling staking into district
 *
 * @dev Manages state describing staking history
 * This contract is not accessed directly, but through MutableForwarder. See MutableForwarder.sol for more comments.
 */

contract StakeBank is Ownable, MiniMeTokenProxyTarget {

  MiniMeTokenFactory public constant minimeTokenFactory = MiniMeTokenFactory(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
  using SafeMath for uint256;

  uint256[128] private maxExpArray;

  StakeBankCheckpoint[] public stakeHistory;
  mapping (address => StakeBankCheckpoint[]) private stakesFor;

  struct StakeBankCheckpoint {
    uint256 at;
    uint256 amount;
  }

  /**
   * @dev Constructor for this contract.
   * Native constructor is not used, because users create only forwarders into single instance of this contract,
   * therefore constructor must be called explicitly.

   */
  function construct()
    public
  {
    super.construct(
      address(minimeTokenFactory),
      0x0,
      0,
      "District Voting Token",
      18,
      "DVT",
      false
    );

    owner = msg.sender;
    changeController(owner);
  }

  /**
   * @dev Calculates amount of voting tokens received given amount of staked registry tokens
   * @param _amount Amount of staked registry tokens
   * @return The estimated amount
   */
  function calculateReturnForStake(uint _amount) private view returns (uint) {
    return _amount;
  }

  /**
   * @dev Estimates amount of voting tokens received given amount of staked registry tokens
   * Purpose of this function is to provide number into UI before user submits actual stake transaction
   * @param _amount Amount of staked registry tokens
   * @return The estimated amount
   */
  function estimateReturnForStake(uint _amount) public view returns (uint) {
    return _amount;
  }

  /**
   * @dev Stakes tokens for a user
   * Can be called only by related registry entry contract
   * Generates voting tokens and transfers them to a user
   * @param user Address of a user
   * @param amount Amount of staked registry tokens
   * @return Index of a last stake history entry
   */
  function stakeFor(address user, uint256 amount) public onlyOwner returns (uint) {
    updateStakeBankCheckpointAtNow(stakesFor[user], amount, false);
    updateStakeBankCheckpointAtNow(stakeHistory, amount, false);
    require(generateTokens(user, calculateReturnForStake(amount)));
    return stakeHistory.length - 1;
  }

  /**
   * @dev Unstakes tokens
   * Can be called only by related registry entry contract
   * Destroys voting tokens generated by staking
   * @param user Address of a user
   * @param amount Amount of staked registry tokens
   * @return Index of a last stake history entry
   */
  function unstake(address user, uint256 amount) public onlyOwner returns (uint) {
    require(amount > 0);
    uint staked = totalStakedFor(user);
    uint minted = balanceOf(user);
    require(staked >= amount);
    require(minted >= amount);
    require(destroyTokens(user, amount));
    updateStakeBankCheckpointAtNow(stakesFor[user], amount, true);
    updateStakeBankCheckpointAtNow(stakeHistory, amount, true);
    return stakeHistory.length - 1;
  }

  /**
   * @dev Returns total staked amount for given address
   * @param addr Address of a user
   * @return Amount of staked tokens
   */
  function totalStakedFor(address addr) public view returns (uint256) {
    StakeBankCheckpoint[] storage stakes = stakesFor[addr];
    if (stakes.length == 0) {
      return 0;
    }
    return stakes[stakes.length-1].amount;
  }

  /**
   * @dev Returns total staked amount by all addresses
   * @return Total amount of staked tokens
   */
  function totalStaked() public view returns (uint256) {
    return totalStakedAt(block.number);
  }

  /**
   * @dev Returns block number at which given address staked last time
   * @param addr Address of a user
   * @return Block number
   */
  function lastStakedFor(address addr) public view returns (uint256) {
    StakeBankCheckpoint[] storage stakes = stakesFor[addr];
    if (stakes.length == 0) {
      return 0;
    }
    return stakes[stakes.length-1].at;
  }

  /**
   * @dev Returns total staked amount for given address at given block number
   * @param addr Address of a user
   * @param blockNumber Block number
   * @return Amount of staked tokens
   */
  function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256) {
    return stakedAt(stakesFor[addr], blockNumber);
  }

  /**
   * @dev Returns total staked amount by all addresses at given block number
   * @param blockNumber Block number
   * @return Total amount of staked tokens
   */
  function totalStakedAt(uint256 blockNumber) public view returns (uint256) {
    return stakedAt(stakeHistory, blockNumber);
  }

  /**
   * @dev Adds new stake history entry at current block number
   * @param history StakeBankCheckpoint[]
   * @param amount Amount of tokens staked/unstaked
   * @param isUnstake True if it's unstake operation
   */
  function updateStakeBankCheckpointAtNow(StakeBankCheckpoint[] storage history, uint256 amount, bool isUnstake)
    private {
    uint256 length = history.length;
    if (length == 0) {
      history.push(StakeBankCheckpoint({at: block.number, amount: amount}));
      return;
    }
    StakeBankCheckpoint storage checkpoint;
    if (history[length-1].at < block.number) {
      history.push(StakeBankCheckpoint({at: block.number, amount: history[length-1].amount}));
      checkpoint = history[length];
    } else if (history[length-1].at == block.number) {
      checkpoint = history[length-1];
    }

    if (isUnstake) {
      checkpoint.amount = checkpoint.amount.sub(amount);
    } else {
      checkpoint.amount = checkpoint.amount.add(amount);
    }
  }

  /**
   * @dev Returns amount of staked tokens given stake history and block number
   * @param history StakeBankCheckpoint[]
   * @param blockNumber Block number
   */
  function stakedAt(StakeBankCheckpoint[] storage history, uint256 blockNumber) private view returns (uint256) {
    uint256 length = history.length;
    if (length == 0 || blockNumber < history[0].at) {
      return 0;
    }
    if (blockNumber >= history[length-1].at) {
      return history[length-1].amount;
    }
    uint min = 0;
    uint max = length-1;
    while (max > min) {
      uint mid = (max + min + 1) / 2;
      if (history[mid].at <= blockNumber) {
        min = mid;
      } else {
        max = mid-1;
      }
    }
    return history[min].amount;
  }
}
